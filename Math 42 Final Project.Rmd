---
title: "Math 42 Project"
author: "Gavin Mora & Ian Kim"
date: "2025-12-05"
output: pdf_document
---

```{r}
library(ggplot2)
library(reshape2)
library(dplyr)
library(tidyr)
```


### Setup
```{r}
set.seed(42)

individuals <- 20
n_states <- 5
max_tsteps <- 260

# All individuals start in stage 3
ind_states <- rep(3, individuals)

# Store state history
stage_history <- matrix(NA, nrow = max_tsteps, ncol = individuals)
stage_history[1, ] <- ind_states
```

### Friendship Levels Matrix
```{r}
# Randomly assign levels of friendship (0 to 3) between every pair of individuals
friendship_probs <- c('0' = 0.8, '1' = 0.12, '2' = 0.06, '3' = 0.02) # probabilities of friendship levels

# Create a 20x20 matrix storing these random levels of friendships
friendship_levels <- matrix(NA_integer_, individuals, individuals)
friendship_levels[upper.tri(friendship_levels)] <- sample(0:3, sum(upper.tri(friendship_levels)),
                                                          replace = TRUE, prob = friendship_probs)
friendship_levels[lower.tri(friendship_levels)] <- t(friendship_levels)[lower.tri(friendship_levels)]

diag(friendship_levels) <- NA # relationships with oneself are set to NA
```

### Friendship Levels Matrix Plot
```{r}
friendship_df <- melt(friendship_levels)
colnames(friendship_df) <- c("From_Individual", "To_Individual", "Friendship_Level")

ggplot(friendship_df, aes(x = From_Individual, y = To_Individual, fill = Friendship_Level)) +
  geom_tile() +
  geom_text(aes(label = Friendship_Level)) +
  scale_fill_gradient(low = "white", high = "steelblue") +
  labs(title = "Friendship Levels Between Each Pair of Individuals") +
  theme_minimal()
```

### Event Probabilities (This is where you tweak parameters)
```{r}
# Example event probabilities
ind_event_probs <- list(
  # negatives
  short_illness = 0.05,  # go down by 1
  serious_illness = 0.005,   # go down by 3
  unenjoyable_activity = 0.15, # go down by 1
  death_of_familiar = 0.005,  # jump to stage 1
  relationship_conflicts = 0.05,  # go down by 2
  financial_insecurity = 0.01, # go down by 2
  unemployment = 0.005,   # go down by 3
    
  # positives
  career_advancement = 0.05,  # go up by 1
  enjoyable_activity = 0.1,  # go up by 1
  personal_goal = 0.15,  # go up by 1
  relationship_renewal = 0.01 # go up by 2
)

global_event_probs <- list(
  natural_disaster = 0.01,  # go down by 2
  economic_downturn = 0.02  # go down by 1
)
# You can add more and adjust transitions below.
```

### Transitions for Each Event
```{r}
apply_global_event <- function(states, event){

  if (event == "natural_disaster"){
    # Go down by 3 stages but not below 1
    return(pmax(states - 2, 1))
  }
  
  if (event == "economic_downturn"){
    # Go down by 1 stage but not below 1
    return(pmax(states - 1, 1))
  }
  
  stop("Unknown global event")
}

apply_ind_event <- function(current_state, event) {
  
  if (event == "short_illness") {
    # Go down by 1 stage but not below 1
    return(max(current_state - 1, 1))
  }
  
  if (event == "unenjoyable_activity") {
    # Go down by 1 stage but not below 1
    return(max(current_state - 1, 1))
  }
  
  if (event == "death_of_familiar") {
    # Jump to stage 1
    return(1)
  }
  
  if (event == "relationship_conflicts") {
    # Go down by 2 stages but not below 1
    return(max(current_state - 2, 1))
  }
  
  if (event == "financial_insecurity") {
    # Go down by 2 stages but not below 1
    return(max(current_state - 2, 1))
  }  
  
  if (event == "unemployment") {
    # Go down by 3 stages but not below 1
    return(max(current_state - 3, 1))
  }
  
  if (event == "serious_illness") {
    # Go down by 3 stages but not below 1
    return(max(current_state - 3, 1))
  }
  
  if (event == "career_advancement") {
    # Go up by 1 stage but not above 5
    return(min(current_state + 1, 5))
  }
  
  if (event == "enjoyable_activity") {
    # Go up by 1 stage but not above 5
    return(min(current_state + 1, 5))
  }
  
  if (event == "personal_goal") {
    # Go up by 1 stage but not above 5
    return(min(current_state + 1, 5))
  }
  
  if (event == "relationship_renewal") {
    # Go up by 2 stages but not above 5
    return(min(current_state + 2, 5))
  }
  
  stop("Unknown individual event")
}
```


### Run Simulation
```{r}
for (t in 2:max_tsteps) {
  
  # Simulate global events
  for (gev in names(global_event_probs)) {
    if (runif(1) < global_event_probs[[gev]]) {
      ind_states <- apply_global_event(ind_states, gev)
    }
  }
  
  for (i in 1:individuals) {
    # Simulate individual events
    for (ev in names(ind_event_probs)) {
      if (runif(1) < ind_event_probs[[ev]]) {
        ind_states[i] <- apply_ind_event(ind_states[i], ev)
      }
    }
    # Simulate friends influencing happiness of other friends
    friends_happiness <- 0 # weighted sum depending on friendship level
    total_weight <- 0
    for (j in 1:individuals) {
      if (!is.na(friendship_levels[i, j]) & friendship_levels[i, j] != 0) {
        # Add each friends' effect on happiness depending on friendship level & their happiness last week
        friends_happiness <- friends_happiness + (friendship_levels[i, j]^2 * stage_history[t-1, j])
        total_weight <- total_weight + (friendship_levels[i, j]^2)
      }
    }
    # Check first if current subject has any friends
    if (total_weight != 0) {
      fh_weighted_avg <- friends_happiness / total_weight
      friend_influence <- min(total_weight / 50, 1)
      ind_states[i] <- min(max(round(((1 - friend_influence) * ind_states[i]) +
                                       (friend_influence * fh_weighted_avg)), 1), 5)
    }
  }
  
  stage_history[t, ] <- ind_states
}
```


### Prep for GGPlot
```{r}
history_df <- as.data.frame(stage_history)
colnames(history_df) <- paste0("Ind_", 1:individuals)
history_df$Time <- 1:max_tsteps

plot_df <- history_df %>%
  pivot_longer(cols = starts_with("Ind_"),
               names_to = "Individual",
               values_to = "Stage")
```

### Plot
```{r}
t_target <- max_tsteps

### 1. Create stacking index (one stack per stage)
plot_stacked <- plot_df %>%
  group_by(Time, Stage) %>%
  mutate(Stack = row_number()) %>%
  ungroup()

### 2. Filter for the chosen time step
plot_single <- plot_stacked %>%
  filter(Time == t_target)

### 3. Plot the stacked dots
ggplot(plot_single, aes(x = factor(Stage), y = Stack)) +
  geom_point(color = "black", size = 3) +
  scale_x_discrete(drop = FALSE) +
  scale_y_continuous(limits = c(0.5, max(plot_single$Stack) + 0.5)) +
  labs(
    title = paste("Stacked Dot Plot for Time =", t_target),
    x = "Stage",
    y = ""
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    legend.position = "none"
  )

```

### Transition Matrix
```{r}
# Initialize a 5x5 matrix
trans_mat <- matrix(0, nrow = n_states, ncol = n_states)

# Loop over time steps and individuals
for (t in 1:(max_tsteps - 1)) {
  for (i in 1:individuals) {
    from <- stage_history[t, i]
    to   <- stage_history[t + 1, i]
    trans_mat[from, to] <- trans_mat[from, to] + 1
  }
}

# Convert counts to probabilities (row sums = 1)
trans_mat <- trans_mat / rowSums(trans_mat)

# Optional: add row/col names
rownames(trans_mat) <- paste0("Stage_", 1:n_states)
colnames(trans_mat) <- paste0("Stage_", 1:n_states)

trans_mat
```

### Transiton Matrix Plot
```{r}
trans_df <- melt(trans_mat)
colnames(trans_df) <- c("From", "To", "Probability")

ggplot(trans_df, aes(x = From, y = To, fill = Probability)) +
  geom_tile() +
  geom_text(aes(label = round(Probability, 2))) +
  scale_fill_gradient(low = "white", high = "steelblue") +
  labs(title = "Transition Matrix") +
  theme_minimal()
```

```{r}
# Compute population mean happiness at each week
history_df["population_mean"] <- rowMeans(history_df[, 1:individuals])

# I tried plotting all individuals' happiness trajectories over time too, but the plot looks bad
# history_df_long <- history_df %>% pivot_longer(
#   cols = c(names(history_df[, names(history_df) != "Time"])),
#   names_to = "series",
#   values_to = "happiness"
# )

# Plots population mean happiness levels over time
ggplot(history_df, aes(x = Time, y = population_mean)) +
  geom_line() +
  labs(
    x = "Time (Weeks)",
    y = "Population Mean Happiness",
    title = paste("Population Mean of Happiness Levels Over", max_tsteps / 52, "Years")
  ) +
  theme_minimal() +
  coord_cartesian(xlim = c(1, max_tsteps), ylim = c(1.5, 4.5))
```